# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**GoZod** is a TypeScript Zod v4-inspired validation library for Go, providing strongly-typed, zero-dependency data validation with intelligent type inference. It maintains complete API compatibility with TypeScript Zod v4 while leveraging Go's type system for compile-time safety.

### Key Features
- **Complete Strict Type Semantics** - All methods require exact input types, zero automatic conversions
- **Maximum Performance** - Zero-overhead validation with optimal execution paths
- **TypeScript Zod v4 Compatible API** - Familiar syntax with Go-native optimizations
- **Rich Validation Methods** - Comprehensive built-in validators for all Go types

## Commands

### Testing
```bash
# Run all tests with race detection
make test

# Run individual package tests  
go test ./types/
go test ./internal/engine/
go test -run TestSpecificFunction ./types/

# Run tests with verbose output
go test -v ./...
```

### Linting and Code Quality
```bash
# Run full lint suite (includes golangci-lint and mod tidy)
make lint

# Run only golangci-lint
make golangci-lint

# Run only module tidy check
make tidy-lint
```

### Building
```bash
# Download dependencies
go mod download

# Build all packages (verify compilation)
go build ./...

# Clean build artifacts
make clean
```

## High-Level Architecture

### Core Design Philosophy
1. **Complete Strict Type Semantics** - All methods require exact input types, zero automatic conversions
2. **Input-Output Symmetry** - Schemas return the same type they accept after validation 
3. **Copy-on-Write Modifiers** - Modifiers like `.Optional()` clone internals and return new instances
4. **TypeScript Zod v4 Compatibility** - Maintains identical API surface and behavior

### Layered Architecture
```
gozod/
├── bin/           # Build outputs and tools
├── coerce/        # Root-level coercion utilities  
├── core/          # Foundation contracts (interfaces, types, constants)
├── docs/          # Documentation and guides
├── examples/      # Example implementations and usage
├── internal/      # Private runtime engine (parser, checks, issues)
├── locales/       # Internationalization bundles
├── pkg/           # Reusable utilities (validate, coerce, reflectx, etc.)  
└── types/         # Public schema implementations (String, Array, etc.)
```

#### One-Way Dependency Rule
- `types/` never import each other; all cross-type logic lives in `internal/`, `pkg/`, or `coerce/`
- Core layer contains zero business logic; only defines contracts and helpers
- Strict separation of concerns: parsing, checking, issue creation, and error formatting live in separate packages
- Root-level files: `gozod.go` (main API), `json_schema.go` (JSON Schema generation), `Makefile` (build automation)

### Key Components

#### Core Layer (`core/`) - Foundation Contracts
- `interfaces.go` - Primary interfaces (`ZodType[T]`, `ZodSchema`, `Cloneable`)
- `definition.go` - Schema definition primitives (`ZodTypeDef`, `SchemaParams`)
- `parsing.go` - Parse contexts and utilities
- `transform.go` - Transformation & pipeline primitives
- `checks.go` - Generic check contracts & helpers
- `context.go` - Parse context, payload & path helpers
- `issues.go` - Error types (`ZodIssue`, `ZodError`)
- `constants.go` - Library-wide constants (issue codes, type ids)
- `config.go` - Global config & default error map
- `registry.go` - Schema metadata and registration system

#### Types Layer (`types/`) - Schema Implementations
Each file implements one schema type following the three-layer template:
```go
// Definition Layer
type ZodString struct { internals core.ZodTypeInternals }

// Internals Layer (auto-generated by factory helpers)

// Public API Layer  
func (z *ZodString) Parse(input any) (string, error)
func (z *ZodString) StrictParse(input string) (string, error)
func (z *ZodString) Min(min int) *ZodString
func (z *ZodString) Optional() *ZodString
```

**File Organization:**
- One schema type per file (e.g., `string.go`, `integer.go`)
- Schema types organized by category:
  - **Primitives**: `string.go`, `bool.go`, `integer.go`, `float.go`, `bigint.go`, `complex.go`
  - **Special Types**: `any.go`, `unknown.go`, `never.go`, `nil.go`
  - **Collections**: `array.go`, `slice.go`, `map.go`, `record.go`
  - **Objects**: `object.go`, `struct.go`
  - **Composition**: `union.go`, `discriminated_union.go`, `intersection.go`
  - **Functions**: `function.go`
  - **Formats**: `email.go`, `network.go`, `ids.go`, `iso.go`, `time.go`, `file.go`
  - **Text**: `text.go`, `stringbool.go`
  - **Advanced**: `lazy.go`, `literal.go`, `enum.go`, `transform.go`
- All schema files include comprehensive test counterparts (`*_test.go`)

#### Internal Engine (`internal/`) - Runtime Engine (Private)
- `engine/` - Generic parser, coercion and check runner
  - `parser.go`, `checker.go`, `types.go`, `errors.go`, `params.go`
- `checks/` - Concrete check factories (length, numeric, format)
  - `checks.go`, `custom.go`, `format.go`, `length.go`, `numeric.go`, `strings.go`, `file.go`
- `issues/` - Raw issue builders, finalisers & formatters
  - `creators.go`, `formatters.go`, `finalize.go`, `errors.go`, `types.go`, `raw.go`, `accessors.go`
- `utils/` - Low-level helpers used only by the engine
  - `utils.go`

#### Pkg Layer (`pkg/`) - Utilities
Stateless, allocation-conscious helpers independent of GoZod runtime:
- `validate/` - Atomic, reflection-free validators (length, numeric, regex, ISO 8601)
- `coerce/` - Loss-less type coercion helpers (`ToInt64`, `ToBool`)
- `reflectx/` - Safe reflection helpers, type guards, deref utils
- `mapx/` - Generic map manipulation (string & generic keys)
- `slicex/` - Generic slice helpers (merge, unique, map)
- `structx/` - Struct ⇄ map conversion without `encoding/json`
- `regexes/` - Pre-compiled, namespaced regex library

### Type System Design

#### Complete Strict Type Semantics
All schemas require exact input types with zero automatic conversions:
- `String()` requires `string` input, returns `string`
- `StringPtr()` requires `*string` input, returns `*string` 
- No automatic conversions between value and pointer types
- For flexible input handling, use Optional/Nilable modifiers

#### Modifier Pattern
```go
// Optional/Nilable: flexible input, pointer output
schema := String().Optional()  // Flexible input (string/*string), returns *string

// Default/Prefault: preserve current type
schema := String().Default("hello")  // Returns *ZodString[string]
```

#### Parse vs StrictParse Methods
- `Parse(input any)` - Accepts any type, performs runtime type checking
- `StrictParse(input T)` - Accepts exact type T, compile-time type safety
- All types should implement both methods for API consistency

#### Constructor Pattern
Every type has value and pointer constructors:
```go
String()    // Creates ZodString[string]
StringPtr() // Creates ZodString[*string]
Int()       // Creates ZodInteger[int, int]  
IntPtr()    // Creates ZodInteger[*int, *int]
```

#### Root-Level Coercion (`coerce/`)
High-level coercion utilities that bridge between `pkg/coerce` and the schema system:
- `coerce.go` - Type coercion integration with schema validation
- `coerce_test.go` - Tests for coercion functionality

## Development Guidelines

### File Organization Patterns
- **Schema Files**: One schema type per file in `types/` (e.g., `string.go`, `integer.go`)
- **Test Files**: Comprehensive test files mirror source file names (`string_test.go`, `integer_test.go`)
- **All files follow 8-section template** from schema implementation guide
- **Internal Organization**:
  - Check factories in `internal/checks/` grouped by concern (`numeric.go`, `strings.go`)
  - Engine components grouped by function (`parser.go`, `checker.go`, `types.go`)
  - Issue handling separated by responsibility (`creators.go`, `formatters.go`, `errors.go`)
- **Package Naming**: Never use underscores; files use underscores for clarity (`coerce_test.go`)

### Naming Conventions & Code Style
- **Schema constructors**: `String()`, `Int()`, `Bool()`
- **Pointer variants**: `StringPtr()`, `IntPtr()`, `BoolPtr()`
- **Methods follow Go conventions**: `Min()`, `Max()`, `Email()`
- **Go-style naming**: Public types/methods capitalized, meaningful names
- **Code formatting**: Always run `gofmt` and `goimports` before committing
- **Package organization**: Organize by function, avoid circular dependencies, minimize public API

### Default vs Prefault Semantics (Critical Zod v4 Compatibility)

#### Default - Short-Circuit Mechanism
- If input is `nil`, **directly returns default value**
- **Does NOT go through** schema parsing, validation, or transformation
- Default value must be compatible with schema's **output type**
- Zero overhead when triggered

#### Prefault - Preprocessing Mechanism  
- If input is `nil`, uses prefault value for **complete parsing flow**
- Prefault value must be compatible with schema's **input type**
- **Only triggered on `nil` input** - validation failures do NOT trigger prefault
- Goes through full validation and transformation pipeline

```go
// Default example - short-circuit
schema1 := String().Transform(func(s string) int { return len(s) }).Default("default")
result1, _ := schema1.Parse(nil) // => "default" (bypasses transform)

// Prefault example - preprocessing
schema2 := String().Transform(func(s string) int { return len(s) }).Prefault("hello")
result2, _ := schema2.Parse(nil) // => 5 ("hello" goes through transform)
```

### Key Development Patterns
1. **Copy-on-Write Modifiers** - Always clone internals before modification, ensure immutability
2. **Type-Safe Method Chaining** - Each method returns strongly-typed schema
3. **Input-Output Symmetry** - Schemas return same type they accept after validation
4. **Composable Validation Pipeline** - Checks are first-class citizens
5. **Zero-Allocation Fast Paths** - Optimize common validation scenarios
6. **Engine-First Architecture** - All parsing through `engine.ParsePrimitive` or `engine.ParseComplex`
7. **Helper Package Usage** - Never roll custom validation/parsing/coercion; use existing packages
8. **Three-Layer Template** - All schema files follow Definition/Internals/Public API layers

### Testing Approach
- **Unit Tests**: Comprehensive tests for each schema type in `*_test.go` files
- **Integration Tests**: Cross-package validation in `internal/` packages  
- **Performance Benchmarks**: Critical path optimization validation
- **Prefault/Default Testing**: Verify correct Zod v4 semantic behavior
- **StrictParse Coverage**: Ensure all types implement both Parse and StrictParse
- Follow existing test patterns for consistency

### Performance Optimization Guidelines

#### Core Optimization Principles
- **Elegance First**: Prioritize code readability over aggressive optimization
- **Progressive Improvement**: Implement optimizations incrementally
- **Balanced Approach**: 10-20% performance gains with maintained code quality

#### Memory & Runtime Optimization
- **Pre-compile regex patterns** at package level in `pkg/regexes`
- **Minimize reflection usage** (relegated to `pkg/reflectx`)
- **Zero-overhead validation paths** with optimal execution
- **Object pools** for frequently allocated objects (`sync.Pool`)
- **String building** with `strings.Builder` instead of concatenation
- **Early return patterns** to avoid unnecessary computations
- **Hot path optimization** for most frequently executed code

#### Compile-Time Optimization
- **Generic constraints** to reduce runtime overhead
- **Type assertion optimization** using type switches
- **Inline functions** for simple operations
- **Pre-extracted constants** for magic numbers

## Important Design Decisions

1. **Complete Strict Type Semantics** - All methods require exact input types, zero automatic conversions
2. **Zod v4 Compatibility First** - Maintain identical API surface and behavior
3. **Pointer Identity Preservation** - Optional/Nilable maintain input pointer addresses when appropriate
4. **Immutable Modifiers** - Modifiers create new instances via copy-on-write
5. **Unified Engine Architecture** - ParsePrimitive/ParseComplex for consistent behavior
6. **Go Idioms** - Error values instead of exceptions, interfaces over inheritance
7. **Zero Dependencies** - Pure Go implementation, no external libraries

## Error Handling

Errors follow structured patterns with rich formatting options:
```go
// Standard validation error
_, err := schema.Parse(input)
if err != nil {
    var zodErr *gozod.ZodError
    if gozod.IsZodError(err, &zodErr) {
        // Handle structured validation errors
        for _, issue := range zodErr.Issues {
            fmt.Printf("Error: %s at %v\n", issue.Message, issue.Path)
        }
    }
}
```

**Error System Features:**
- Structured error handling with custom formatting
- Internationalization support through `locales/` packages  
- Path tracking for nested validation failures
- Multiple output formats for different use cases

## Integration Points

- **JSON Schema Generation** - Convert GoZod schemas to JSON Schema format
- **Internationalization** - Built-in i18n bundles in `locales/` packages
- **Custom Error Formatting** - Flexible error output via `internal/issues`
- **Metadata System** - Attach custom metadata to schemas via Registry
- **Transform & Pipeline Support** - Composable data transformation

## API Consistency Requirements

**All schema types must implement:**
- `Parse(input any) (T, error)` - Runtime type checking
- `StrictParse(input T) (T, error)` - Compile-time type safety  
- `MustParse(input any) T` - Panic on error
- `MustStrictParse(input T) T` - Panic on error with strict typing
- `GetInternals() *core.ZodTypeInternals` - Access internals
- `IsOptional() bool` - Check if schema is optional
- `IsNilable() bool` - Check if schema allows nil
- `Coerce(input any) (any, bool)` - Type coercion capability

**Engine API Usage Patterns:**
- **Primitive types**: Use `engine.ParsePrimitive` and `engine.ParsePrimitiveStrict`
- **Complex types**: Use `engine.ParseComplex` and `engine.ParseComplexStrict`
- **Never bypass engine APIs** - maintains consistent modifier handling
- **Type constraints**: Use proper generic constraints (`StringConstraint interface { string | *string }`)

## Code Quality Standards

### Documentation Requirements
- **Every public type**: Complete GoDoc comments
- **Every public method**: Clear usage examples and parameter descriptions
- **Complex logic**: Inline comments explaining reasoning
- **API changes**: Update corresponding documentation

### Testing Requirements
- **Unit tests**: Every public method with comprehensive coverage
- **Integration tests**: Complex workflows and cross-package validation
- **Performance tests**: Benchmark tests for critical paths
- **Race detection**: All tests must pass with `-race` flag

### Code Review Standards
- **Type safety**: All type assertions and conversions must be safe
- **Error handling**: All error cases properly handled following Go idioms
- **Performance**: No unnecessary allocations or computations
- **Compatibility**: Changes must not break TypeScript Zod v4 compatibility

## Development Workflow

### Implementation Order
1. **Define type structure** (Def, Internals, main type)
2. **Implement core interfaces** (ZodType, Parse, StrictParse methods)
3. **Add validation methods** (Min, Max, specific checks)
4. **Implement modifiers** (Optional, Nilable, Default, Prefault)
5. **Add advanced features** (Refine, Transform, Pipe)
6. **Write comprehensive tests** with full coverage
7. **Add documentation and examples**

### Build System Integration
```bash
# Standard development commands
make test     # Run all tests with race detection
make lint     # Run golangci-lint and mod tidy checks  
make build    # Build all packages
make clean    # Clean build artifacts
```

This architecture ensures type safety, performance, and complete compatibility with TypeScript Zod v4 while embracing Go language idioms and providing maximum developer productivity.
