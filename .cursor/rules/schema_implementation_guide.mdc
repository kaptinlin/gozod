# GoZod Schema Implementation Guide

A practical reference for building **new schema types** inside the GoZod code-base.  
It targets **Cursor AI** and human contributors alike: every rule here exists to keep
implementations consistent, type-safe and performant.

This guide is based on the latest patterns from `string.go`, `object.go`, and their test counterparts.

---

## 1  Core Principles

1. **Complete Strict Type Semantics** – All methods require exact input types, zero automatic conversions. Both `Parse(any)` and `StrictParse(T)` must be implemented.
2. **Zero-overhead abstractions** – primitives allocate nothing, composites allocate lazily.  
3. **Unified architecture** – every file follows the same 8-section layout so Cursor can pattern-match and extend it.  
4. **Copy-on-Write modifiers** – modifiers clone internals; the original instance is immutable.  
5. **Engine-first architecture** – All parsing must go through `engine.ParsePrimitive` or `engine.ParseComplex`.
6. **Mandatory helper packages** – *never* roll your own validation, parsing, coercion or error logic.

---

## 2  Type Classification Cheat-Sheet

| Scenario                          | Architecture                    | Generic pattern                         | Example |
|-----------------------------------|---------------------------------|-----------------------------------------|---------|
| Native Go value (string / int…)   | Single generic + constraint     | `ZodType[T Constraint]`  `Constraint: T \| *T` | `Bool`, `String`, `Float` |
| Requires value comparison (`==`)  | Comparable + dual generic       | `ZodType[T comparable, R any]`          | `Enum`, `Literal` |
| Composite / user struct / slice   | Dual generic                    | `ZodType[T any, R any]`                 | `Struct`, `Slice`, `Map` |

Decision flow  `▶`  Native? → Comparable? → Composite.

---

## 3  Mandatory 8-Section File Layout

Every schema file *must* keep sections in this exact order so automated tooling can
inject code safely:

1. **TYPE CONSTRAINTS**   – union constraints (`StringConstraint interface { string | *string }`)
2. **TYPE DEFINITIONS**   – `ZodTypeDef`, `ZodTypeInternals`, public `ZodType[T]`
3. **CORE METHODS**       – `GetInternals`, `IsOptional`, `IsNilable`, `Parse`, `MustParse`, `StrictParse`, `MustStrictParse`, `Coerce`
4. **MODIFIER METHODS**   – `Optional`, `Nilable`, `Default`, `Prefault`, `Overwrite`, etc.
5. **VALIDATION METHODS** – Type-specific validations (`Min`, `Max`, `Email`, etc.)
6. **TRANSFORM & PIPE**   – `Transform`, `Pipe`, `Overwrite`
7. **REFINEMENT METHODS** – `Refine`, `RefineAny`, `Check`
8. **CONSTRUCTORS**       – `Type()`, `TypePtr()`, `CoercedType()`, constructor helpers

> Keep the section banners – Cursor relies on them when autofilling code.

---

## 4  Helper Packages – **Use Them or Break the Build**

| Purpose      | Package                  | Must use |
|--------------|--------------------------|-----------|
| Validation   | `internal/checks`        | ✅ |
| Parsing      | `internal/engine`        | ✅ |
| Error build  | `internal/issues`        | ✅ |
| Type convert | `pkg/coerce`             | ✅ |
| Param utils  | `internal/utils`         | ✅ |

### Example – adding a min-length check
```go
func (z *ZodString[T]) Min(n int, p ...any) *ZodString[T] {
    chk := checks.MinLength(n, p...)
    ni  := z.internals.ZodTypeInternals.Clone()
    ni.AddCheck(chk)
    return z.withInternals(ni)
}
```
No custom check structs, no manual error creation.

---

## 5  Engine Integration Patterns

### 5.1  Primitives - ParsePrimitive Pattern
```go
func (z *ZodString[T]) Parse(input any, ctx ...*core.ParseContext) (T, error) {
    // Use internally recorded type code, fallback to default
    expectedType := z.internals.Type
    if expectedType == "" {
        expectedType = core.ZodTypeString
    }

    return engine.ParsePrimitive[string, T](
        input,
        &z.internals.ZodTypeInternals,
        expectedType,                                   // type code from internals
        engine.ApplyChecks[string],                     // validator function
        engine.ConvertToConstraintType[string, T],      // constraint converter
        ctx...,
    )
}

func (z *ZodString[T]) StrictParse(input T, ctx ...*core.ParseContext) (T, error) {
    expectedType := z.internals.Type
    if expectedType == "" {
        expectedType = core.ZodTypeString
    }

    return engine.ParsePrimitiveStrict[string, T](
        input,
        &z.internals.ZodTypeInternals,
        expectedType,
        engine.ApplyChecks[string],
        engine.ConvertToConstraintType[string, T],
        ctx...,
    )
}
```

### 5.2  Composites - ParseComplex Pattern
```go
func (z *ZodObject[T, R]) Parse(input any, ctx ...*core.ParseContext) (R, error) {
    result, err := engine.ParseComplex[map[string]any](
        input,
        &z.internals.ZodTypeInternals,
        core.ZodTypeObject,
        z.extractObjectForEngine,      // extract function
        z.extractObjectPtrForEngine,   // extract pointer function
        z.validateObjectForEngine,     // validation function
        ctx...,
    )
    if err != nil {
        var zero R
        return zero, err
    }

    // Convert result to constraint type R
    if objectMap, ok := result.(map[string]any); ok {
        return convertToObjectConstraintType[T, R](any(objectMap).(T)), nil
    }
    
    var zero R
    return zero, fmt.Errorf("failed to convert object result")
}
```

**Key Points:**
- **`base`** – concrete Go type stored internally (`string`, `map[string]any`, etc.)
- **`constraint`** – user-visible generic type (`T` or `*T`)
- Always provide both `Parse` and `StrictParse` implementations
- `Parse(any)` provides runtime type checking and flexible input handling
- `StrictParse(T)` provides compile-time type safety and exact type matching
- Use type-specific extract and validate functions for complex types
- Both methods should use the same validation pipeline but different input handling

---

## 6  Copy-on-Write Modifier Rules

1. Modifiers **never** mutate `z.internals` – always `Clone()` first.
2. Pointer-returning modifiers (`Optional`, `Nilable`, `Nullish`) switch **only**
   the **constraint** type, not the base type.
3. `Default`, `Prefault` keep the original generic `T` and accept value types for compile-time safety.
4. `Transform` changes the output type to the transformed type.
5. `withInternals` / `withPtrInternals` must preserve `Def` to share immutable
   data.

---

## 7  Primitive Type – Full Template

Below is the complete pattern based on current String implementation:

```go
// TYPE CONSTRAINTS
type StringConstraint interface {
    string | *string
}

// TYPE DEFINITIONS
type ZodStringDef struct {
    core.ZodTypeDef
}

type ZodStringInternals struct {
    core.ZodTypeInternals
    Def *ZodStringDef // Schema definition
}

type ZodString[T StringConstraint] struct {
    internals *ZodStringInternals
}

// CORE METHODS
func (z *ZodString[T]) GetInternals() *core.ZodTypeInternals {
    return &z.internals.ZodTypeInternals
}

func (z *ZodString[T]) IsOptional() bool {
    return z.internals.ZodTypeInternals.IsOptional()
}

func (z *ZodString[T]) IsNilable() bool {
    return z.internals.ZodTypeInternals.IsNilable()
}

func (z *ZodString[T]) Coerce(input any) (any, bool) {
    result, err := coerce.ToString(input)
    return result, err == nil
}

func (z *ZodString[T]) Parse(input any, ctx ...*core.ParseContext) (T, error) {
    expectedType := z.internals.Type
    if expectedType == "" {
        expectedType = core.ZodTypeString
    }

    return engine.ParsePrimitive[string, T](
        input,
        &z.internals.ZodTypeInternals,
        expectedType,
        engine.ApplyChecks[string],
        engine.ConvertToConstraintType[string, T],
        ctx...,
    )
}

func (z *ZodString[T]) MustParse(input any, ctx ...*core.ParseContext) T {
    result, err := z.Parse(input, ctx...)
    if err != nil {
        panic(err)
    }
    return result
}

func (z *ZodString[T]) StrictParse(input T, ctx ...*core.ParseContext) (T, error) {
    expectedType := z.internals.Type
    if expectedType == "" {
        expectedType = core.ZodTypeString
    }

    return engine.ParsePrimitiveStrict[string, T](
        input,
        &z.internals.ZodTypeInternals,
        expectedType,
        engine.ApplyChecks[string],
        engine.ConvertToConstraintType[string, T],
        ctx...,
    )
}

func (z *ZodString[T]) MustStrictParse(input T, ctx ...*core.ParseContext) T {
    result, err := z.StrictParse(input, ctx...)
    if err != nil {
        panic(err)
    }
    return result
}

// MODIFIER METHODS
func (z *ZodString[T]) Optional() *ZodString[*string] {
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetOptional(true)
    return z.withPtrInternals(ni)
}

func (z *ZodString[T]) Nilable() *ZodString[*string] {
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetNilable(true)
    return z.withPtrInternals(ni)
}

func (z *ZodString[T]) Nullish() *ZodString[*string] {
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetOptional(true)
    ni.SetNilable(true)
    return z.withPtrInternals(ni)
}

func (z *ZodString[T]) Default(defaultValue string) *ZodString[T] {
    // Default accepts value type, not pointer
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetDefault(defaultValue)
    return z.withInternals(ni)
}

func (z *ZodString[T]) Prefault(prefaultValue string) *ZodString[T] {
    // Prefault accepts value type, not pointer  
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetPrefault(prefaultValue)
    return z.withInternals(ni)
}

// VALIDATION METHODS
func (z *ZodString[T]) Min(min int, params ...any) *ZodString[T] {
    check := checks.MinLength(min, params...)
    ni := z.internals.ZodTypeInternals.Clone()
    ni.AddCheck(check)
    return z.withInternals(ni)
}

// TRANSFORM & PIPE
func (z *ZodString[T]) Transform(fn func(string, *core.RefinementContext) (any, error)) *core.ZodTransform[T, any] {
    wrapper := func(input T, ctx *core.RefinementContext) (any, error) {
        return fn(extractString(input), ctx)
    }
    return core.NewZodTransform[T, any](z, wrapper)
}

// REFINEMENT METHODS
func (z *ZodString[T]) Refine(fn func(string) bool, params ...any) *ZodString[T] {
    check := checks.NewRefine[string](fn, params...)
    ni := z.internals.ZodTypeInternals.Clone()
    ni.AddCheck(check)
    return z.withInternals(ni)
}

// CONSTRUCTORS
func String(params ...core.SchemaParams) *ZodString[string] {
    return createStringSchema[string](core.ZodTypeString, params...)
}

func StringPtr(params ...core.SchemaParams) *ZodString[*string] {
    return createStringSchema[*string](core.ZodTypeString, params...)
}
```

**Key Requirements:**
- Both `Parse` and `StrictParse` must be implemented for complete API
- `Parse(any)` for flexible runtime input, `StrictParse(T)` for compile-time safety
- Both `MustParse` and `MustStrictParse` panic-based versions required
- `Default` and `Prefault` accept value types, not pointers
- All modifier methods must clone internals (Copy-on-Write)
- Use engine integration patterns consistently
- StrictParse should bypass runtime type checking when possible

---

## 8  Composite Type Sketch – Slice

```go
// Constraints optional – slices accept any element type

type ZodSliceDef[T any] struct{
    core.ZodTypeDef
    Element core.ZodType[any]
}

type ZodSliceInternals[T any] struct{
    core.ZodTypeInternals
    Def     *ZodSliceDef[T]
    Element core.ZodType[any]
}

type ZodSlice[T any,R any] struct{ internals *ZodSliceInternals[T] }

// Parse logic delegates element validation to Element schema
func (z *ZodSlice[T,R]) Parse(in any, ctx ...*core.ParseContext)(R,error){
    return engine.ParseType[R](
        in, &z.internals.ZodTypeInternals, core.ZodTypeSlice,
        extractSlice[T], validateSlice[T], ctx...,
    )
}
```

### Element Validation Helpers
* `extractSlice`: fast path for `[]T` and `[]*T`.
* `validateSlice`: length checks + per-item `Element.Parse`.

---

## 9  Transform ‑vs- Overwrite ‑vs- Pipe

| Method    | Type change | Stored as    | Best for |
|-----------|-------------|--------------|----------|
| Transform | ✔           | `ZodTransform` | Return a *different* type after validation |
| Overwrite | ✖           | `checks.Overwrite` | Mutate value but keep schema type |
| Pipe      | Depends     | `ZodPipe`      | Chain validation to another schema |

Implementation pattern (no converter struct):
```go
// Transform example
return core.NewZodTransform(z, func(in T,c *core.RefinementContext)(any,error){
    return fn(extract(in),c)
})
```

---

## 10  Validation Method Rules

* Always obtain checks via `checks.*` (Min, Regex, Custom…).
* For custom logic wrap the user callback inside `checks.NewCustom` so engine can
  aggregate issues.

```go
check := checks.NewCustom[any](wrapper, params...)
ni    := z.internals.Clone(); ni.AddCheck(check)
return z.withInternals(ni)
```

---

## 11  Error Handling

The only way to surface an error is through `internal/issues` – this keeps payload
formatting consistent across all types.

```go
return issues.NewZodError(issues.ConvertRawIssuesToIssues(raw, ctx))
```

No direct `fmt.Errorf` inside parsing/validation code.

---

## 12  Testing Checklist

1. **Parse success** – valid input returns typed value.
2. **Modifier chain** – `Optional().Default()` works and original schema untouched.
3. **Error branches** – invalid input produces an error with correct path/type.
4. **Pointer identity** – pointer constraints preserve identity when possible.
5. **Race + bench** – `go test -race`, `go test -bench=.`.

---

## 13  Common Pitfalls

* **Missing StrictParse Implementation** – All schemas must implement both `Parse(any)` and `StrictParse(T)` for complete type-safe semantics. `Parse` provides flexibility, `StrictParse` provides compile-time guarantees.
* **Mis-ordering the 8 sections** – Cursor inserts code in wrong spot.  
* **`Default(v R)` instead of `Default(v T)`** – breaks API consistency.  
* **Default/Prefault Type Safety** – `Default(value T)` and `Prefault(value T)` must accept value types (string), not pointer types (*string), for compile-time safety.
* **Engine Integration Bypass** – All parsing must go through `engine.ParsePrimitive` or `engine.ParseComplex`.
* **Direct Type Assertions** – Direct reflection / `.(type)` violates principle #1.  
* **Shared State Bugs** – Forgetting `ni := internals.Clone()` leads to shared-state bugs.  
* **Missing Helper Usage** – Adding validation without `checks.*` package breaks consistency.
* **Type Code Handling** – Not using `z.internals.Type` with proper fallbacks breaks type detection.
* **Default/Prefault Semantics** – Misunderstanding that Default short-circuits validation while Prefault goes through full parsing.

---

## 14  Implementation → PR Checklist

- [ ] File respects 8-section order & headings.  
- [ ] All helper packages imported (`internal/engine`, `internal/checks`, `pkg/coerce`).  
- [ ] Both `Parse(any)` and `StrictParse(T)` implemented using engine helpers.
- [ ] `Parse` method handles `any` input with runtime type checking.
- [ ] `StrictParse` method accepts exact constraint type `T` with compile-time safety.
- [ ] Both methods share the same validation pipeline and modifier handling.
- [ ] Both `MustParse` and `MustStrictParse` implemented.
- [ ] `GetInternals`, `IsOptional`, `IsNilable` methods implemented.
- [ ] Modifiers follow Copy-on-Write pattern + pointer conversion rules.  
- [ ] Default/Prefault accept value types, not pointers (compile-time safety).
- [ ] Coerce method implemented for primitive types.
- [ ] Type constraints defined correctly (`T | *T` pattern).
- [ ] Comprehensive unit tests added following test guide structure.  
- [ ] Public constructors exported in `gozod.go`.  
- [ ] JSON Schema support added if applicable.
- [ ] Documentation updated for public API changes.

---

Follow this playbook and new GoZod schemas will automatically inherit the library's
performance, safety and DX guarantees.
