---
description:
globs:
alwaysApply: false
---

# GoZod Coding Standards and Best Practices

This document defines comprehensive coding standards and best practices for the GoZod validation library. It provides guiding principles for implementing Go code that ensures full compatibility with the TypeScript Zod v4 API while following Go language idioms and performance optimization principles.

## üéØ Core Design Philosophy

### 1. Smart Type Inference First
- **Input-Output Consistency**: Output the same type as input
- **Preserve Go Type Inference Advantages**: `String().Parse("hello")` ‚Üí `string`, `String().Parse(&"hello")` ‚Üí `*string`
- **Nilable Modifier Semantics**: Only changes handling of `nil`, doesn't change type inference logic
- **Avoid Type Coercion**: Let Go's type system work naturally
- **Compile-time Type Safety**: Use type system to prevent incorrect usage at compile time

### 2. Full TypeScript Zod v4 Correspondence
- **Complete API Compatibility**: Maintain the same method signatures, parameters, and return value structures
- **Behavioral Consistency**: Same input produces same output
- **Error Handling Correspondence**: Error types and messages correspond to TypeScript version
- **Field Naming Consistency**: Use the same naming conventions as JS version

### 3. Go Language Idioms
- **Use Go 1.21+ Features**: Fully utilize generics and performance optimizations
- **Follow Go Conventions**: Error handling, naming conventions, package organization
- **Value Types First**: Use value types rather than pointer types for struct fields
- **Zero-Allocation Optimization**: Avoid memory allocation when possible

### 4. Avoid Over-Engineering
- **Simplified Implementation**: Direct inlining rather than complex function wrapping
- **Remove Unnecessary Wrapping**: Avoid intermediate variables and wrapper functions
- **Unified Patterns**: Use consistent design patterns, avoid special cases
- **Progressive Complexity**: Start simple, add complexity as needed

## üèóÔ∏è Architectural Design Principles

### 1. Three-Layer Architecture Pattern
- **Definition Layer**: Basic type definitions and configuration information
- **Internals Layer**: Internal type implementation, including parse functions, check lists, etc.
- **Public Interface Layer**: Provides public APIs for user use

### 2. Unified Wrapper Pattern
- **Default Wrapper**: Type-safe default value functionality
- **Prefault Wrapper**: Type-safe fallback value functionality
- **Optional Wrapper**: Handles missing field semantics
- **Nilable Flag**: Set flag directly on original type, preserve smart inference

### 3. Separation of Concerns Principle
- **Refine**: Only validates data, never modifies data
- **Transform**: Can modify data type and content
- **Coerce**: Performs type coercion before parsing
- **Check**: Low-level validation mechanism, supports complex validation logic

## üìä TypeScript to GoZod Mapping

### Basic Type Mapping

| TypeScript Zod v4 | Go Type | GoZod Constructor | Description |
|-------------------|---------|----------------|-------------|
| `z.string()` | `string` | `gozod.String()` | String validation with Parse/StrictParse |
| `z.number()` | `float64` | `gozod.Number()`, `gozod.Float64()` | Number validation (default float64) |
| `z.boolean()` | `bool` | `gozod.Bool()` | Boolean validation |
| `z.array(T)` | `[]T` | `gozod.Slice(T)`, `gozod.Array(T)` | Dynamic array/slice validation |
| `z.object({})` | `struct` | `gozod.Object({})`, `gozod.Struct[T]()` | Object/struct validation |
| `z.union([])` | `any` | `gozod.Union([])` | Union type validation |
| `z.coerce.string()` | `string` | `gozod.CoercedString()`, `coerce.String()` | Type coercion validation |

### Parse Method Duality

| TypeScript Zod v4 | GoZod Method | Input Type | Performance | Use Case |
|-------------------|-------------|------------|-------------|----------|
| `.parse(data)` | `.Parse(data)` | `any` | Standard | Unknown input types, API validation |
| `.safeParse(data)` | `.Parse(data)` | `any` | Standard | Go uses (T, error) pattern |
| - | `.StrictParse(data)` | `T` | 3-5x faster | Known types, internal validation |
| - | `.MustParse(data)` | `any` | Standard + panic | Critical failures |
| - | `.MustStrictParse(data)` | `T` | 3-5x faster + panic | Type-safe critical failures |

### Modifier Mapping

| TypeScript Zod v4 | GoZod | Semantic Differences |
|-------------------|-------|--------------------- |
| `.optional()` | `.Optional()` | Missing field handling, returns `*T` |
| `.nullable()` | `.Nilable()` | Null value handling, returns `*T` |
| `.nullish()` | `.Nullish()` | Combines optional and nullable, returns `*T` |
| `.default(value)` | `.Default(value)` | Short-circuits validation for nil input |
| `.catch(value)` | `.Prefault(value)` | Goes through full validation pipeline |
| - | `.DefaultFunc(func)` | **Go enhancement**: Function-based defaults |
| - | `.PrefaultFunc(func)` | **Go enhancement**: Function-based prefaults |

### Validation Method Mapping

| TypeScript Zod v4 | GoZod | Return Type | Go-Specific Features |
|-------------------|-------|-------------|---------------------|
| `.min(n)` | `.Min(n)` | Same type, supports method chaining | Works with all Go numeric types |
| `.max(n)` | `.Max(n)` | Same type, supports method chaining | Works with all Go numeric types |
| `.refine(fn)` | `.Refine(fn)` | Same type, type-safe | Go error handling pattern |
| `.transform(fn)` | `.Transform(fn)` | `ZodType[T, any]`, supports type conversion | Go error handling |
| `.pipe(schema)` | `.Pipe(schema)` | Pipeline connection | Full pipeline support |

### Custom Validator System

| Feature | TypeScript Zod v4 | GoZod | Status |
|---------|-------------------|-------|--------|
| **Custom refinements** | `.refine(fn)` | `.Refine(fn)` + `validators.Register()` | ‚úÖ Enhanced |
| **Registry system** | Not available | `validators.Register(&CustomValidator{})` | ‚úÖ Go enhancement |
| **Struct tag integration** | Not available | `gozod:"required,custom_validator"` | ‚úÖ Go enhancement |
| **Parameterized validators** | Custom logic | `ZodParameterizedValidator` interface | ‚úÖ Go enhancement |

## üîß Go Language Idiom Guidelines

### 0. General Principles
- **Simplicity first**: Write simple, clear, idiomatic Go code; favor readability over cleverness.
- **Happy path left-aligned**: Return early to reduce nesting and keep the main flow flush left.
- **Useful zero values**: Design types so that their zero value is meaningful and immediately usable.

### 1. Error Handling Patterns
```go
// ‚úÖ Standard Go error handling
result, err := schema.Parse(input)
if err != nil {
    return fmt.Errorf("validation failed: %w", err)
}

// ‚ùå Avoid exception style
try {
    result := schema.MustParse(input)
} catch (err) {
    // Not Go convention
}
```

### 2. Interface Design Principles
```go
// ‚úÖ Small and focused interfaces
type ZodCheck interface {
    GetZod() *ZodCheckInternals
}

type Cloneable interface {
    CloneFrom(source any)
}

// ‚ùå Avoid large, all-encompassing interfaces
type ZodEverything interface {
    Parse(...) (any, error)
    Validate(...) error
    Transform(...) any
    // ... too many methods
}
```

### 3. Package Organization Principles
- **Organize by Function**: Core types, validation checks, error handling organized separately
- **Avoid Circular Dependencies**: Clear dependency relationship diagram
- **Minimize Public API**: Only export necessary types and functions
- **Hide Internal Implementation**: Use internal packages or private fields

### 4. Naming Conventions
```go
// ‚úÖ Go-style naming
type ZodString struct { ... }
func (z *ZodString) Min(min int) *ZodString { ... }
var EmailRegex = regexp.MustCompile(...)

// ‚ùå Avoid non-Go style
type zodString struct { ... }  // Private types should have good reason
func (z *ZodString) min(min int) *ZodString { ... }  // Public methods should be capitalized
var emailRegex = ...  // Package-level variables should be capitalized
```

### 5. Code Style & Formatting
- Always run `gofmt` and `goimports` before committing.
- Keep line length reasonable and use blank lines to separate logical sections for readability.

### 6. Concurrency Guidelines
- Let the caller decide when to launch goroutines; libraries should not spawn them arbitrarily.
- Always define clear termination conditions for goroutines and prevent leaks with `sync.WaitGroup`, contexts, or channels.
- Communicate between goroutines via channels; protect shared state with `sync.Mutex`/`sync.RWMutex` when necessary.
- Close channels from the sender side and leverage `select` for non-blocking operations.

## üöÄ Performance Optimization Guidelines

### 0. Core Optimization Principles
- **Elegance First, Moderate Optimization**: Prioritize code readability and maintainability over aggressive optimization
- **Avoid Over-Engineering**: Focus on practical performance improvements, avoid excessive complexity
- **Balance Performance and Maintainability**: Find the optimal balance between performance gains and code elegance
- **Progressive Improvement**: Implement optimizations incrementally, each step independently verifiable

### 1. Memory Allocation Optimization
- **Pre-allocate Slices**: Use `make([]T, 0, capacity)` when size is known
- **Object Pools**: Use `sync.Pool` for frequently allocated objects
- **String Building**: Use `strings.Builder` instead of string concatenation
- **Avoid Unnecessary Copying**: Use pointers to pass large structs
- **Reduce Boxing/Unboxing**: Minimize type conversions and interface{} usage
- **Zero-Allocation Fast Paths**: Optimize common scenarios to avoid allocations

### 2. Compile-Time Optimization
- **Pre-compile Regular Expressions**: Pre-compile common regex at package level
- **Extract Constants**: Extract magic numbers as named constants
- **Inline Functions**: Use inlining for simple functions instead of function calls
- **Type Assertion Optimization**: Use type switch instead of multiple assertions
- **Generic Constraints**: Leverage compile-time type binding to reduce runtime overhead
- **Compile-Time Type Safety**: Use generics to eliminate runtime type checks where possible

### 3. Runtime Optimization
- **Early Return**: Check and return as early as possible
- **Conditional Execution**: Avoid unnecessary computations
- **Cache Results**: Cache expensive computation results
- **Batch Operations**: Combine multiple small operations into batch operations
- **Hot Path Optimization**: Identify and optimize the most frequently executed code paths
- **Reduce Function Call Overhead**: Minimize indirect calls and unnecessary function layers

### 4. Reflection and Type Conversion Optimization
- **Minimize Reflection Usage**: Use reflection only when absolutely necessary
- **Fast Path for Common Types**: Provide compile-time optimized paths for frequent types
- **Reduce Type Assertions**: Leverage generics to avoid runtime type checking
- **Smart Nil Checking**: Optimize nil detection for different type categories
- **Direct Type Operations**: Use direct generic operations instead of interface{} conversions

### 5. Parser and Validation Optimization
- **Super Fast Path**: Implement ultra-fast paths for simple validation scenarios
- **Condition Ordering**: Place most common conditions first in conditional chains
- **Merge Similar Logic**: Consolidate repeated type checking and validation patterns
- **Reduce Indirection**: Minimize function pointer calls and indirect operations
- **Lazy Evaluation**: Defer expensive operations until actually needed

## üéØ TypeScript vs Go Difference Handling

### 1. Type System Differences
| Concept | TypeScript | Go | Handling Strategy |
|---------|------------|----|-----------------|
| Optional fields | `field?: T` | `*T` pointer | Copy-on-Write modifier (`Optional()`) |
| Union types | `T \| U` | `any` + type assertion | Runtime type checking |
| Literal types | `"literal"` | Constants + validation | Enum validation |
| Generic constraints | `T extends U` | `T interface{ ... }` | Interface constraints |
| Custom validation | `.refine()` only | Registry + struct tags | Enhanced validation |

### 2. Runtime Behavior Differences
- **undefined vs nil**: TypeScript's `undefined` corresponds to Go's `nil`
- **Type Coercion**: TypeScript's implicit conversion vs Go's explicit conversion  
- **Error Handling**: TypeScript's exceptions vs Go's error values
- **Async Processing**: TypeScript's Promise vs Go's synchronous processing
- **Validation Flexibility**: Parse vs StrictParse for different use cases

### 3. API Design Differences
```go
// TypeScript: Method chaining
// z.string().min(5).max(10).email()

// Go: Maintain same chaining with Parse/StrictParse duality
schema := gozod.String().Min(5).Max(10).Email()
result, err := schema.Parse(unknownInput)      // Runtime type checking
result, err = schema.StrictParse(knownString) // Compile-time type safety

// TypeScript: Optional parameters
// z.string().min(5, { message: "Too short" })

// Go: Use struct parameters
gozod.String().Min(5, core.SchemaParams{Error: "Too short"})

// Go enhancement: Declarative struct tags
type User struct {
    Name string `gozod:"required,min=5,max=10"`
}
schema := gozod.FromStruct[User]()
```

## üè∑Ô∏è Struct Tag Validation System

### Core Tag Rules

| Struct Tag Rule | Programmatic API Equivalent | Example | Status |
|-----------------|----------------------------|---------|--------|
| `gozod:"required"` | Field without `.Optional()` | `Name string \`gozod:"required"\`` | ‚úÖ Implemented |
| `gozod:"min=N"` | `.Min(N)` | `Name string \`gozod:"min=2"\`` | ‚úÖ Implemented |
| `gozod:"max=N"` | `.Max(N)` | `Name string \`gozod:"max=50"\`` | ‚úÖ Implemented |
| `gozod:"email"` | `.Email()` | `Email string \`gozod:"email"\`` | ‚úÖ Implemented |
| `gozod:"custom_validator"` | Custom validator | `Username string \`gozod:"required,unique_username"\`` | ‚úÖ Implemented |

### Custom Validator Integration

```go
// Register custom validator
validators.Register(&UniqueUsernameValidator{})

// Use in struct tags
type User struct {
    Username string `gozod:"required,unique_username"`        // Basic validator
    Age      int    `gozod:"required,min_age=21"`           // Parameterized validator
    Email    string `gozod:"required,email"`                // Built-in validator
}

// Generate schema from tags
schema := gozod.FromStruct[User]()
result, err := schema.Parse(user)
```

### Validator Interfaces

```go
// Basic validator
type ZodValidator[T any] interface {
    Name() string
    Validate(value T) bool
    ErrorMessage(ctx *core.ParseContext) string
}

// Parameterized validator
type ZodParameterizedValidator[T any] interface {
    ZodValidator[T]
    ValidateParam(value T, param string) bool
    ErrorMessageWithParam(ctx *core.ParseContext, param string) string
}
```

## üîÑ Unified Design Patterns

### 1. Parse vs StrictParse Pattern
Every schema type provides both flexible and type-safe parsing:

```go
// Flexible parsing - accepts any type, runtime type checking
func (z *ZodString[T]) Parse(input any, ctx ...*core.ParseContext) (T, error)

// Type-safe parsing - compile-time type safety, optimal performance
func (z *ZodString[T]) StrictParse(input T, ctx ...*core.ParseContext) (T, error)

// Panic-based variants for critical error scenarios
func (z *ZodString[T]) MustParse(input any, ctx ...*core.ParseContext) T
func (z *ZodString[T]) MustStrictParse(input T, ctx ...*core.ParseContext) T
```

### 2. Complete Strict Type Semantics Pattern
All schemas enforce strict type requirements with no automatic conversions:

```go
// Value schemas - require exact value types
stringSchema := gozod.String()      // Only accepts string
intSchema := gozod.Int()            // Only accepts int
structSchema := gozod.Struct[T]()   // Only accepts T

// Pointer schemas - require exact pointer types  
stringPtrSchema := gozod.StringPtr()    // Only accepts *string
intPtrSchema := gozod.IntPtr()          // Only accepts *int
structPtrSchema := gozod.StructPtr[T]() // Only accepts *T

// Use Optional/Nilable for flexible input
optionalSchema := gozod.String().Optional()  // Flexible input, *string output
```

### 3. Copy-on-Write Modifier Pattern

Each modifier clones the schema's internal state and returns a **new instance**, ensuring immutability and type-safe chaining without auxiliary wrapper structs:

```go
// Optional() ‚Äì converts to pointer type and marks as optional
func (z *ZodBool[T]) Optional() *ZodBool[*bool] {
    in := z.internals.ZodTypeInternals.Clone()
    in.SetOptional(true)
    return z.withPtrInternals(in)
}

// Nilable() ‚Äì converts to pointer type and allows nil values
func (z *ZodBool[T]) Nilable() *ZodBool[*bool] {
    in := z.internals.ZodTypeInternals.Clone()
    in.SetNilable(true)
    return z.withPtrInternals(in)
}

// Default() ‚Äì retains original generic type while setting default value
func (z *ZodBool[T]) Default(v bool) *ZodBool[T] {
    in := z.internals.ZodTypeInternals.Clone()
    in.SetDefaultValue(v)
    return z.withInternals(in)
}
```

**Usage Examples:**

```go
// ‚úÖ Correct: Modifiers return new instances
originalSchema := String()
optionalSchema := originalSchema.Optional() // Returns new *ZodString[*string]

// ‚úÖ Correct: Type-safe chaining
schema := String().Min(1).Max(100).Optional()

// ‚úÖ Correct: Default accepts value type, compile-time type safety
schema := String().Default("hello") // Accepts string, not *string

// ‚ùå Wrong: Modifying original instance
schema.internals.isOptional = true // Direct state modification

// ‚ùå Wrong: Passing pointer to Default (compile-time prevention)
// schema := String().Default(&"hello") // Compile error
```

Key characteristics:

- **Immutable modifier chain**: Original schema is never mutated.
- **Pointer semantics**: Optional/Nilable always return pointer type (`*T`).
- **No wrapper structs**: Eliminates `ZodOptional`, `ZodNilable`, `ZodStringDefault`, etc., reducing allocations.
- **Type inference preserved**: Default/Prefault keep the current generic type `T`; Optional/Nilable switch to `*T`.

## üìù Code Quality Standards

### 1. Documentation Requirements
- **Every public type**: Must have complete GoDoc comments
- **Every public method**: Must have clear usage examples and parameter descriptions
- **Complex logic**: Must have inline comments explaining the reasoning
- **API changes**: Must update corresponding documentation

### 2. Testing Requirements
- **Unit tests**: Every public method must have comprehensive unit tests
- **Integration tests**: Complex workflows must have integration tests
- **Performance tests**: Critical paths must have benchmark tests

### 3. Code Review Standards
- **Type safety**: All type assertions and conversions must be safe
- **Error handling**: All error cases must be properly handled
- **Performance**: No unnecessary allocations or computations
- **Compatibility**: Changes must not break TypeScript compatibility

## üõ†Ô∏è Development Workflow

### 1. Implementation Order
1. **Define type structure** (Def, Internals, main type)
2. **Implement core interfaces** (ZodType, Parse method)
3. **Add validation methods** (Min, Max, specific checks)
4. **Implement modifiers** (Optional, Nilable, Default)
5. **Add advanced features** (Refine, Transform, Pipe)
6. **Write comprehensive tests**
7. **Add documentation and examples**

### 2. Code Organization
- **One type per file**: Each schema type in its own file
- **Related functionality grouped**: Validation checks near type definition
- **Clear dependencies**: Import only what's needed
- **Consistent patterns**: Follow established patterns across all types

### 3. Version Management
- **Semantic versioning**: Follow semver for all releases
- **Backward compatibility**: Maintain compatibility within major versions
- **Deprecation warnings**: Provide clear migration paths for deprecated features
- **Change documentation**: Document all API changes with examples

## üéØ Performance Optimization Implementation Guidelines

### 1. Optimization Implementation Principles
- **Don't Over-Optimize**: Avoid introducing complex abstractions for marginal gains
- **Maintain Elegance**: Prioritize code simplicity and maintainability over aggressive optimization
- **Progressive Improvement**: Implement simple, effective optimizations first; avoid large-scale refactoring
- **Thorough Validation**: Every optimization must have corresponding performance and functional tests

### 2. Risk Assessment and Mitigation
- **Code Complexity**: Balance performance optimization with code readability
- **Regression Risk**: Optimizations may introduce new bugs; require comprehensive testing
- **Maintenance Cost**: Over-optimization may increase future maintenance difficulty
- **API Compatibility**: Ensure optimizations don't affect existing APIs and behavior

### 3. Success Metrics for Performance Optimization
- **Moderate Performance Gains**: Target 10-20% performance improvement (realistic goals)
- **Reduced System Overhead**: Minimize reflection calls and unnecessary allocations
- **100% Test Coverage**: Maintain complete test pass rate
- **Code Elegance**: Keep code clean and readable
- **No Breaking Changes**: Avoid introducing breaking changes

### 4. Optimization Implementation Phases
1. **Phase 1: Low-Hanging Fruit**: Optimize obvious inefficiencies (reflection, type conversions)
2. **Phase 2: Hot Path Optimization**: Focus on most frequently executed code paths
3. **Phase 3: Advanced Optimizations**: Implement more sophisticated optimizations if needed
4. **Phase 4: Performance Validation**: Benchmark testing and functional verification

### 5. Performance Testing Requirements
- **Baseline Benchmarks**: Establish performance baselines before optimization
- **Comparative Testing**: Compare before/after performance metrics
- **Regression Testing**: Ensure optimizations don't break existing functionality
- **Real-World Scenarios**: Test with realistic data and usage patterns

This document serves as the authoritative guide for all GoZod development, ensuring consistency, quality, and compatibility across the entire codebase.
