package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestCodeGenerator_ProcessPackage(t *testing.T) {
	tests := []struct {
		name            string
		setupFiles      map[string]string // filename -> content
		config          *GeneratorConfig
		expectError     bool
		expectedFiles   []string
		unexpectedFiles []string
	}{
		{
			name: "simple package with one struct",
			setupFiles: map[string]string{
				"user.go": `package main
import "time"

type User struct {
	ID        string    ` + "`json:\"id\" gozod:\"required,uuid\"`" + `
	Name      string    ` + "`json:\"name\" gozod:\"required,min=2,max=50\"`" + `
	Email     string    ` + "`json:\"email\" gozod:\"required,email\"`" + `
	CreatedAt time.Time ` + "`json:\"created_at\" gozod:\"required\"`" + `
}`,
			},
			config: &GeneratorConfig{
				OutputSuffix: "_gen.go",
				PackageName:  "main",
				Verbose:      false,
				DryRun:       false,
			},
			expectError:   false,
			expectedFiles: []string{"user_gen.go"},
		},
		{
			name: "package with multiple structs",
			setupFiles: map[string]string{
				"models.go": `package main

type User struct {
	ID   string ` + "`gozod:\"required,uuid\"`" + `
	Name string ` + "`gozod:\"required,min=2\"`" + `
}

type Product struct {
	ID    string  ` + "`gozod:\"required,uuid\"`" + `
	Name  string  ` + "`gozod:\"required,min=1\"`" + `
	Price float64 ` + "`gozod:\"required,gt=0\"`" + `
}`,
			},
			config: &GeneratorConfig{
				OutputSuffix: "_schema.go",
				PackageName:  "main",
				Verbose:      false,
				DryRun:       false,
			},
			expectError:   false,
			expectedFiles: []string{"user_schema.go", "product_schema.go"},
		},
		{
			name: "dry run mode",
			setupFiles: map[string]string{
				"user.go": `package main
type User struct {
	Name string ` + "`gozod:\"required\"`" + `
}`,
			},
			config: &GeneratorConfig{
				OutputSuffix: "_gen.go",
				PackageName:  "main",
				Verbose:      false,
				DryRun:       true,
			},
			expectError:     false,
			expectedFiles:   []string{}, // No files should be created in dry run
			unexpectedFiles: []string{"user_gen.go"},
		},
		{
			name: "no structs with gozod tags",
			setupFiles: map[string]string{
				"empty.go": `package main
type User struct {
	Name string ` + "`json:\"name\"`" + ` // No gozod tag
}`,
			},
			config: &GeneratorConfig{
				OutputSuffix: "_gen.go",
				PackageName:  "main",
				Verbose:      false,
				DryRun:       false,
			},
			expectError:     false,
			expectedFiles:   []string{}, // No files should be generated
			unexpectedFiles: []string{"empty_gen.go"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			helper := NewTestHelper(t)

			// Create test files
			for filename, content := range tt.setupFiles {
				helper.CreateGoFile(filename, content)
			}

			// Override output directory in config
			tt.config.PackageName = "main"

			// Create generator
			generator, err := NewCodeGenerator(tt.config)
			if err != nil {
				t.Fatalf("Failed to create generator: %v", err)
			}

			// Update writer to use temp directory
			writer, err := NewFileWriter(helper.GetTempDir(), tt.config.PackageName, tt.config.OutputSuffix, tt.config.DryRun, tt.config.Verbose)
			if err != nil {
				t.Fatalf("Failed to create writer: %v", err)
			}
			generator.writer = writer

			// Process package
			err = generator.ProcessPackage(helper.GetTempDir())
			if tt.expectError && err == nil {
				t.Error("Expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("Unexpected error: %v", err)
			}

			// Check expected files
			for _, expectedFile := range tt.expectedFiles {
				helper.AssertFileExists(expectedFile)
			}

			// Check unexpected files
			for _, unexpectedFile := range tt.unexpectedFiles {
				helper.AssertFileNotExists(unexpectedFile)
			}

			// If files were generated, check their content
			if !tt.config.DryRun && len(tt.expectedFiles) > 0 {
				for _, filename := range tt.expectedFiles {
					content := helper.ReadGeneratedFile(filename)
					helper.AssertValidGoCode(content)
					helper.AssertCodeContains(content,
						"// Code generated by gozodgen. DO NOT EDIT.",
						"github.com/kaptinlin/gozod",
					)
					helper.AssertCodeNotContains(content,
						"github.com/kaptinlin/gozod/core",
					)
				}
			}
		})
	}
}

func TestCodeGenerator_CircularReferences(t *testing.T) {
	helper := NewTestHelper(t)

	// Create a file with circular references
	content := `package main

type Node struct {
	Value    int     ` + "`json:\"value\" gozod:\"required\"`" + `
	Next     *Node   ` + "`json:\"next\" gozod:\"\"`" + `
	Children []*Node ` + "`json:\"children\" gozod:\"\"`" + `
}

type Department struct {
	Name      string      ` + "`json:\"name\" gozod:\"required\"`" + `
	Manager   *Employee   ` + "`json:\"manager\" gozod:\"\"`" + `
	Employees []*Employee ` + "`json:\"employees\" gozod:\"\"`" + `
}

type Employee struct {
	Name       string      ` + "`json:\"name\" gozod:\"required\"`" + `
	Department *Department ` + "`json:\"department\" gozod:\"\"`" + `
	Reports    []*Employee ` + "`json:\"reports\" gozod:\"\"`" + `
}`

	helper.CreateGoFile("circular.go", content)

	config := &GeneratorConfig{
		OutputSuffix: "_gen.go",
		PackageName:  "main",
		Verbose:      false,
		DryRun:       false,
	}

	generator, err := NewCodeGenerator(config)
	if err != nil {
		t.Fatalf("Failed to create generator: %v", err)
	}

	// Update writer to use temp directory
	writer, err := NewFileWriter(helper.GetTempDir(), config.PackageName, config.OutputSuffix, config.DryRun, config.Verbose)
	if err != nil {
		t.Fatalf("Failed to create writer: %v", err)
	}
	generator.writer = writer

	err = generator.ProcessPackage(helper.GetTempDir())
	if err != nil {
		t.Fatalf("Failed to process package: %v", err)
	}

	// Check each generated file exists
	expectedFiles := []string{"node_gen.go", "department_gen.go", "employee_gen.go"}

	for _, fileName := range expectedFiles {
		helper.AssertFileExists(fileName)
		content := helper.ReadGeneratedFile(fileName)
		helper.AssertValidGoCode(content)

		// Should not import core
		helper.AssertCodeNotContains(content,
			"github.com/kaptinlin/gozod/core",
		)
	}

	// Check for self-references use Lazy (Node.Next and Employee.Reports)
	nodeContent := helper.ReadGeneratedFile("node_gen.go")
	helper.AssertCodeContains(nodeContent,
		"gozod.Lazy(func() gozod.ZodType[any] { return gozod.FromStruct[Node]() })",
	)

	empContent := helper.ReadGeneratedFile("employee_gen.go")
	helper.AssertCodeContains(empContent,
		"gozod.Lazy(func() gozod.ZodType[any] { return gozod.FromStruct[Employee]() })",
	)

	// Cross-references use direct FromStruct (for now)
	deptContent := helper.ReadGeneratedFile("department_gen.go")
	helper.AssertCodeContains(deptContent,
		"gozod.FromStruct[Employee]()",
	)

	helper.AssertCodeContains(empContent,
		"gozod.FromStruct[Department]()",
	)
}

func TestCodeGenerator_ComplexValidation(t *testing.T) {
	helper := NewTestHelper(t)

	content := `package main

type Product struct {
	ID       string   ` + "`json:\"id\" gozod:\"required,uuid\"`" + `
	SKU      string   ` + "`json:\"sku\" gozod:\"required,regex=^[A-Z0-9\\\\-]+$\"`" + `
	Name     string   ` + "`json:\"name\" gozod:\"required,min=1,max=200\"`" + `
	Price    float64  ` + "`json:\"price\" gozod:\"required,gt=0.0\"`" + `
	Currency string   ` + "`json:\"currency\" gozod:\"required,enum=USD EUR GBP JPY\"`" + `
	Tags     []string ` + "`json:\"tags\" gozod:\"min=0,max=10\"`" + `
	Active   *bool    ` + "`json:\"active\" gozod:\"default=true\"`" + `
}`

	helper.CreateGoFile("product.go", content)

	config := &GeneratorConfig{
		OutputSuffix: "_gen.go",
		PackageName:  "main",
		Verbose:      false,
		DryRun:       false,
	}

	generator, err := NewCodeGenerator(config)
	if err != nil {
		t.Fatalf("Failed to create generator: %v", err)
	}

	writer, err := NewFileWriter(helper.GetTempDir(), config.PackageName, config.OutputSuffix, config.DryRun, config.Verbose)
	if err != nil {
		t.Fatalf("Failed to create writer: %v", err)
	}
	generator.writer = writer

	err = generator.ProcessPackage(helper.GetTempDir())
	if err != nil {
		t.Fatalf("Failed to process package: %v", err)
	}

	helper.AssertFileExists("product_gen.go")

	generatedContent := helper.ReadGeneratedFile("product_gen.go")
	helper.AssertValidGoCode(generatedContent)

	// Check specific validations
	helper.AssertCodeContains(generatedContent,
		`"id": gozod.Uuid()`,
		`.Regex(regexp.MustCompile("^[A-Z0-9\\-]+$"))`,
		`.Min(1).Max(200)`,
		`.Gt(0.0)`,
		`.Enum("USD", "EUR", "GBP", "JPY")`,
		`.Default(true).Optional()`,
	)

	// Should import regexp for regex validation
	helper.AssertImportsCorrect(generatedContent,
		[]string{"github.com/kaptinlin/gozod", "regexp"},
		[]string{"github.com/kaptinlin/gozod/core"},
	)
}

func TestCodeGenerator_RealTestdata(t *testing.T) {
	testFiles := []string{
		"simple_struct.go",
		"complex_struct.go",
		"circular_struct.go",
	}

	for _, filename := range testFiles {
		t.Run(filename, func(t *testing.T) {
			// Skip if file doesn't exist
			fullPath := filepath.Join("testdata", filename)
			if _, err := os.Stat(fullPath); os.IsNotExist(err) {
				t.Skipf("Testdata file %s not found", filename)
				return
			}

			helper := NewTestHelper(t)

			// Copy testdata file to temp directory
			content, err := os.ReadFile(fullPath)
			if err != nil {
				t.Fatalf("Failed to read testdata file: %v", err)
			}
			helper.CreateGoFile(filename, string(content))

			config := &GeneratorConfig{
				OutputSuffix: "_gen.go",
				PackageName:  "testdata", // Use testdata package name
				Verbose:      false,
				DryRun:       false,
			}

			generator, err := NewCodeGenerator(config)
			if err != nil {
				t.Fatalf("Failed to create generator: %v", err)
			}

			writer, err := NewFileWriter(helper.GetTempDir(), config.PackageName, config.OutputSuffix, config.DryRun, config.Verbose)
			if err != nil {
				t.Fatalf("Failed to create writer: %v", err)
			}
			generator.writer = writer

			err = generator.ProcessPackage(helper.GetTempDir())
			if err != nil {
				t.Fatalf("Failed to process %s: %v", filename, err)
			}

			// Check that generation succeeded
			files := helper.ListGeneratedFiles()
			t.Logf("Generated files for %s: %v", filename, files)

			// Find generated files
			generatedFiles := []string{}
			for _, file := range files {
				if strings.HasSuffix(file, "_gen.go") {
					generatedFiles = append(generatedFiles, file)
				}
			}

			if len(generatedFiles) > 0 {
				for _, genFile := range generatedFiles {
					content := helper.ReadGeneratedFile(genFile)
					helper.AssertValidGoCode(content)
					t.Logf("Successfully generated %s with valid Go code", genFile)
				}
			}
		})
	}
}

func TestNewCodeGenerator(t *testing.T) {
	tests := []struct {
		name        string
		config      *GeneratorConfig
		expectError bool
	}{
		{
			name: "valid config",
			config: &GeneratorConfig{
				OutputSuffix: "_gen.go",
				PackageName:  "main",
				Verbose:      false,
				DryRun:       false,
			},
			expectError: false,
		},
		{
			name:        "nil config",
			config:      nil,
			expectError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			generator, err := NewCodeGenerator(tt.config)
			if tt.expectError && err == nil {
				t.Error("Expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("Unexpected error: %v", err)
			}
			if !tt.expectError && generator == nil {
				t.Error("Expected generator but got nil")
			}
		})
	}
}
