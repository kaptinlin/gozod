# GoZod Schema Implementation Guide

A practical reference for building **new schema types** inside the GoZod code-base.  
It targets **Cursor AI** and human contributors alike: every rule here exists to keep
implementations consistent, type-safe and performant.

This guide is based on the latest patterns from `string.go`, `object.go`, and their test counterparts.

---

## 1  Core Principles

1. **Complete Strict Type Semantics** – All methods require exact input types, zero automatic conversions. Both `Parse(any)` and `StrictParse(T)` must be implemented.
2. **Zero-overhead abstractions** – primitives allocate nothing, composites allocate lazily.  
3. **Unified architecture** – every file follows the same 8-section layout so Cursor can pattern-match and extend it.  
4. **Copy-on-Write modifiers** – modifiers clone internals; the original instance is immutable.  
5. **Engine-first architecture** – All parsing must go through `engine.ParsePrimitive` or `engine.ParseComplex`.
6. **Mandatory helper packages** – *never* roll your own validation, parsing, coercion or error logic.

---

## 2  Type Classification Cheat-Sheet

| Scenario                          | Architecture                    | Generic pattern                         | Example |
|-----------------------------------|---------------------------------|-----------------------------------------|---------|
| Native Go value (string / int…)   | Single generic + constraint     | `ZodType[T Constraint]`  `Constraint: T \| *T` | `Bool`, `String`, `Float` |
| Requires value comparison (`==`)  | Comparable + dual generic       | `ZodType[T comparable, R any]`          | `Enum`, `Literal` |
| Composite / user struct / slice   | Dual generic                    | `ZodType[T any, R any]`                 | `Struct`, `Slice`, `Map` |

Decision flow  `▶`  Native? → Comparable? → Composite.

---

## 3  Mandatory 5-Section File Layout

Every schema file *must* keep sections in this exact order for consistency:

1. **TYPE DEFINITIONS**       – Constraints, `ZodTypeDef`, `ZodTypeInternals`, public `ZodType[T]`
2. **CORE METHODS**           – `GetInternals`, `IsOptional`, `IsNilable`, `Parse`, `StrictParse`, `MustParse`, `MustStrictParse`, `Coerce`
3. **MODIFIER METHODS**       – `Optional`, `Nilable`, `Default`, `Prefault`, `Overwrite`, `Transform`, `Pipe`
4. **VALIDATION & REFINEMENT** – Type-specific validations (`Min`, `Max`, `Email`, etc.), `Refine`, `RefineAny`, `Check`
5. **CONSTRUCTORS**           – `Type()`, `TypePtr()`, `CoercedType()`, constructor helpers

> Keep the section banners – tools rely on them for code navigation.

---

## 4  Helper Packages – **Use Them or Break the Build**

| Purpose      | Package                  | Must use |
|--------------|--------------------------|-----------|
| Validation   | `internal/checks`        | ✅ |
| Parsing      | `internal/engine`        | ✅ |
| Error build  | `internal/issues`        | ✅ |
| Type convert | `pkg/coerce`             | ✅ |
| Param utils  | `internal/utils`         | ✅ |

### Example – adding a min-length check
```go
func (z *ZodString[T]) Min(n int, p ...any) *ZodString[T] {
    chk := checks.MinLength(n, p...)
    ni  := z.internals.ZodTypeInternals.Clone()
    ni.AddCheck(chk)
    return z.withInternals(ni)
}
```
No custom check structs, no manual error creation.

---

## 5  Engine Integration Patterns

### 5.1  Primitives - ParsePrimitive Pattern
```go
func (z *ZodString[T]) Parse(input any, ctx ...*core.ParseContext) (T, error) {
    // Use internally recorded type code, fallback to default
    expectedType := z.internals.Type
    if expectedType == "" {
        expectedType = core.ZodTypeString
    }

    return engine.ParsePrimitive[string, T](
        input,
        &z.internals.ZodTypeInternals,
        expectedType,                                   // type code from internals
        engine.ApplyChecks[string],                     // validator function
        engine.ConvertToConstraintType[string, T],      // constraint converter
        ctx...,
    )
}

func (z *ZodString[T]) StrictParse(input T, ctx ...*core.ParseContext) (T, error) {
    expectedType := z.internals.Type
    if expectedType == "" {
        expectedType = core.ZodTypeString
    }

    return engine.ParsePrimitiveStrict[string, T](
        input,
        &z.internals.ZodTypeInternals,
        expectedType,
        engine.ApplyChecks[string],
        engine.ConvertToConstraintType[string, T],
        ctx...,
    )
}
```

### 5.2  Composites - ParseComplex Pattern
```go
func (z *ZodObject[T, R]) Parse(input any, ctx ...*core.ParseContext) (R, error) {
    result, err := engine.ParseComplex[map[string]any](
        input,
        &z.internals.ZodTypeInternals,
        core.ZodTypeObject,
        z.extractObjectForEngine,      // extract function
        z.extractObjectPtrForEngine,   // extract pointer function
        z.validateObjectForEngine,     // validation function
        ctx...,
    )
    if err != nil {
        var zero R
        return zero, err
    }

    // Convert result to constraint type R
    if objectMap, ok := result.(map[string]any); ok {
        return convertToObjectConstraintType[T, R](any(objectMap).(T)), nil
    }
    
    var zero R
    return zero, fmt.Errorf("failed to convert object result")
}
```

**Key Points:**
- **`base`** – concrete Go type stored internally (`string`, `map[string]any`, etc.)
- **`constraint`** – user-visible generic type (`T` or `*T`)
- Always provide both `Parse` and `StrictParse` implementations
- `Parse(any)` provides runtime type checking and flexible input handling
- `StrictParse(T)` provides compile-time type safety and exact type matching
- Use type-specific extract and validate functions for complex types
- Both methods should use the same validation pipeline but different input handling

---

## 6  Copy-on-Write Modifier Rules

> See `coding-standards.mdc` Section 3.3 for detailed explanation.

Key points:
1. **Never mutate** `z.internals` – always `Clone()` first
2. **Pointer modifiers** (`Optional`, `Nilable`) switch constraint type only
3. **Default/Prefault** keep original generic `T`
4. **Transform** changes output type

---

## 7  Primitive Type – Full Template

Below is the complete pattern based on current String implementation:

```go
// TYPE CONSTRAINTS
type StringConstraint interface {
    string | *string
}

// TYPE DEFINITIONS
type ZodStringDef struct {
    core.ZodTypeDef
}

type ZodStringInternals struct {
    core.ZodTypeInternals
    Def *ZodStringDef // Schema definition
}

type ZodString[T StringConstraint] struct {
    internals *ZodStringInternals
}

// CORE METHODS
func (z *ZodString[T]) GetInternals() *core.ZodTypeInternals {
    return &z.internals.ZodTypeInternals
}

func (z *ZodString[T]) IsOptional() bool {
    return z.internals.ZodTypeInternals.IsOptional()
}

func (z *ZodString[T]) IsNilable() bool {
    return z.internals.ZodTypeInternals.IsNilable()
}

func (z *ZodString[T]) Coerce(input any) (any, bool) {
    result, err := coerce.ToString(input)
    return result, err == nil
}

func (z *ZodString[T]) Parse(input any, ctx ...*core.ParseContext) (T, error) {
    expectedType := z.internals.Type
    if expectedType == "" {
        expectedType = core.ZodTypeString
    }

    return engine.ParsePrimitive[string, T](
        input,
        &z.internals.ZodTypeInternals,
        expectedType,
        engine.ApplyChecks[string],
        engine.ConvertToConstraintType[string, T],
        ctx...,
    )
}

func (z *ZodString[T]) MustParse(input any, ctx ...*core.ParseContext) T {
    result, err := z.Parse(input, ctx...)
    if err != nil {
        panic(err)
    }
    return result
}

func (z *ZodString[T]) StrictParse(input T, ctx ...*core.ParseContext) (T, error) {
    expectedType := z.internals.Type
    if expectedType == "" {
        expectedType = core.ZodTypeString
    }

    return engine.ParsePrimitiveStrict[string, T](
        input,
        &z.internals.ZodTypeInternals,
        expectedType,
        engine.ApplyChecks[string],
        engine.ConvertToConstraintType[string, T],
        ctx...,
    )
}

func (z *ZodString[T]) MustStrictParse(input T, ctx ...*core.ParseContext) T {
    result, err := z.StrictParse(input, ctx...)
    if err != nil {
        panic(err)
    }
    return result
}

func (z *ZodString[T]) ParseAny(input any, ctx ...*core.ParseContext) (any, error) {
    result, err := z.Parse(input, ctx...)
    return any(result), err
}

func (z *ZodString[T]) MustParseAny(input any, ctx ...*core.ParseContext) any {
    result := z.MustParse(input, ctx...)
    return any(result)
}

// MODIFIER METHODS
func (z *ZodString[T]) Optional() *ZodString[*string] {
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetOptional(true)
    return z.withPtrInternals(ni)
}

func (z *ZodString[T]) Nilable() *ZodString[*string] {
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetNilable(true)
    return z.withPtrInternals(ni)
}

func (z *ZodString[T]) Nullish() *ZodString[*string] {
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetOptional(true)
    ni.SetNilable(true)
    return z.withPtrInternals(ni)
}

func (z *ZodString[T]) Default(defaultValue string) *ZodString[T] {
    // Default accepts value type, not pointer
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetDefault(defaultValue)
    return z.withInternals(ni)
}

func (z *ZodString[T]) Prefault(prefaultValue string) *ZodString[T] {
    // Prefault accepts value type, not pointer  
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetPrefault(prefaultValue)
    return z.withInternals(ni)
}

func (z *ZodString[T]) DefaultFunc(fn func() string) *ZodString[T] {
    // Function-based defaults - Go enhancement
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetDefaultFunc(fn)
    return z.withInternals(ni)
}

func (z *ZodString[T]) PrefaultFunc(fn func() string) *ZodString[T] {
    // Function-based prefaults - Go enhancement
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetPrefaultFunc(fn)
    return z.withInternals(ni)
}

func (z *ZodString[T]) Meta(meta core.GlobalMeta) *ZodString[T] {
    // Metadata attachment - Go enhancement
    ni := z.internals.ZodTypeInternals.Clone()
    ni.SetMeta(meta)
    return z.withInternals(ni)
}

// VALIDATION METHODS
func (z *ZodString[T]) Min(min int, params ...any) *ZodString[T] {
    check := checks.MinLength(min, params...)
    ni := z.internals.ZodTypeInternals.Clone()
    ni.AddCheck(check)
    return z.withInternals(ni)
}

// TRANSFORM & PIPE
func (z *ZodString[T]) Transform(fn func(string, *core.RefinementContext) (any, error)) *core.ZodTransform[T, any] {
    wrapper := func(input T, ctx *core.RefinementContext) (any, error) {
        return fn(extractString(input), ctx)
    }
    return core.NewZodTransform[T, any](z, wrapper)
}

// REFINEMENT METHODS
func (z *ZodString[T]) Refine(fn func(string) bool, params ...any) *ZodString[T] {
    check := checks.NewRefine[string](fn, params...)
    ni := z.internals.ZodTypeInternals.Clone()
    ni.AddCheck(check)
    return z.withInternals(ni)
}

func (z *ZodString[T]) Check(name string, fn func(string) bool, params ...any) *ZodString[T] {
    check := checks.NewCustomCheck(name, fn, params...)
    ni := z.internals.ZodTypeInternals.Clone()
    ni.AddCheck(check)
    return z.withInternals(ni)
}

func (z *ZodString[T]) CheckParam(name, param string, fn func(string, string) bool, params ...any) *ZodString[T] {
    check := checks.NewParameterizedCheck(name, param, fn, params...)
    ni := z.internals.ZodTypeInternals.Clone()
    ni.AddCheck(check)
    return z.withInternals(ni)
}

// CONSTRUCTORS
func String(params ...core.SchemaParams) *ZodString[string] {
    return createStringSchema[string](core.ZodTypeString, params...)
}

func StringPtr(params ...core.SchemaParams) *ZodString[*string] {
    return createStringSchema[*string](core.ZodTypeString, params...)
}
```

**Key Requirements:**
- Both `Parse` and `StrictParse` must be implemented for complete API
- `Parse(any)` for flexible runtime input, `StrictParse(T)` for compile-time safety
- Both `MustParse` and `MustStrictParse` panic-based versions required
- `Default` and `Prefault` accept value types, not pointers
- All modifier methods must clone internals (Copy-on-Write)
- Use engine integration patterns consistently
- StrictParse should bypass runtime type checking when possible

---

## 8  Composite Type Sketch – Slice

```go
// Constraints optional – slices accept any element type

type ZodSliceDef[T any] struct{
    core.ZodTypeDef
    Element core.ZodType[any]
}

type ZodSliceInternals[T any] struct{
    core.ZodTypeInternals
    Def     *ZodSliceDef[T]
    Element core.ZodType[any]
}

type ZodSlice[T any,R any] struct{ internals *ZodSliceInternals[T] }

// Parse logic delegates element validation to Element schema
func (z *ZodSlice[T,R]) Parse(in any, ctx ...*core.ParseContext)(R,error){
    return engine.ParseType[R](
        in, &z.internals.ZodTypeInternals, core.ZodTypeSlice,
        extractSlice[T], validateSlice[T], ctx...,
    )
}
```

### Element Validation Helpers
* `extractSlice`: fast path for `[]T` and `[]*T`.
* `validateSlice`: length checks + per-item `Element.Parse`.

---

## 9  Transform ‑vs- Overwrite ‑vs- Pipe

| Method    | Type change | Stored as    | Best for |
|-----------|-------------|--------------|----------|
| Transform | ✔           | `ZodTransform` | Return a *different* type after validation |
| Overwrite | ✖           | `checks.Overwrite` | Mutate value but keep schema type |
| Pipe      | Depends     | `ZodPipe`      | Chain validation to another schema |

Implementation pattern (no converter struct):
```go
// Transform example
return core.NewZodTransform(z, func(in T,c *core.RefinementContext)(any,error){
    return fn(extract(in),c)
})
```

---

## 10  Validation Method Rules

* Always obtain checks via `checks.*` (Min, Regex, Custom…).
* For custom logic wrap the user callback inside `checks.NewCustom` so engine can
  aggregate issues.

```go
check := checks.NewCustom[any](wrapper, params...)
ni    := z.internals.Clone(); ni.AddCheck(check)
return z.withInternals(ni)
```

---

## 11  Error Handling

The only way to surface an error is through `internal/issues` – this keeps payload
formatting consistent across all types.

```go
return issues.NewZodError(issues.ConvertRawIssuesToIssues(raw, ctx))
```

No direct `fmt.Errorf` inside parsing/validation code.

---

## 12  Testing Checklist

1. **Parse success** – valid input returns typed value.
2. **Modifier chain** – `Optional().Default()` works and original schema untouched.
3. **Error branches** – invalid input produces an error with correct path/type.
4. **Pointer identity** – pointer constraints preserve identity when possible.
5. **Race + bench** – `go test -race`, `go test -bench=.`.

---

## 13  Common Pitfalls

* **Missing StrictParse Implementation** – All schemas must implement both `Parse(any)` and `StrictParse(T)` for complete type-safe semantics. `Parse` provides flexibility, `StrictParse` provides compile-time guarantees.
* **Mis-ordering the 8 sections** – Cursor inserts code in wrong spot.  
* **`Default(v R)` instead of `Default(v T)`** – breaks API consistency.  
* **Default/Prefault Type Safety** – `Default(value T)` and `Prefault(value T)` must accept value types (string), not pointer types (*string), for compile-time safety.
* **Engine Integration Bypass** – All parsing must go through `engine.ParsePrimitive` or `engine.ParseComplex`.
* **Direct Type Assertions** – Direct reflection / `.(type)` violates principle #1.  
* **Shared State Bugs** – Forgetting `ni := internals.Clone()` leads to shared-state bugs.  
* **Missing Helper Usage** – Adding validation without `checks.*` package breaks consistency.
* **Type Code Handling** – Not using `z.internals.Type` with proper fallbacks breaks type detection.
* **Default/Prefault Semantics** – Misunderstanding that Default short-circuits validation while Prefault goes through full parsing.

---

## 14  Custom Validation Patterns

GoZod provides custom validation via `Refine`, `Check`, and `CheckParam` methods on all schema types.

### 14.1  Refine – Custom Validation Functions

```go
// Basic refinement with type-safe function
schema := gozod.String().Refine(func(s string) bool {
    return !isReservedUsername(s)
}, "Username is not allowed")

// RefineAny for input-agnostic validation
schema := gozod.String().RefineAny(func(input any) bool {
    s, ok := input.(string)
    return ok && len(s) > 0
}, "Must be a non-empty string")
```

### 14.2  Check – Named Custom Checks

```go
// Named check for reusability and identification
schema := gozod.String().Check("no_spaces", func(s string) bool {
    return !strings.Contains(s, " ")
}, "Must not contain spaces")

// Parameterized check with extra parameters
schema := gozod.String().CheckParam("prefix", "PROD-", func(s, prefix string) bool {
    return strings.HasPrefix(s, prefix)
}, "Must start with the required prefix")
```

### 14.3  Struct Tag Validation

```go
// Struct tags provide declarative validation
type User struct {
    Name  string `gozod:"required,min=2,max=50"`
    Email string `gozod:"required,email"`
    Age   int    `gozod:"required,min=18"`
}

schema := gozod.FromStruct[User]()
result, err := schema.Parse(user)

// Struct-level refinement for cross-field validation
schema = schema.Refine(func(u User) bool {
    return u.Age >= 21 || !strings.Contains(u.Email, "company.com")
}, "Users under 21 cannot have company emails")
```

---

## 15  Numeric String Keys in Record (Zod v4 PR #5585)

Record schemas support numeric key schemas for validating string keys as numbers:

```go
// Basic numeric key validation
schema := Record(Float64(), String())
schema.Parse(map[string]any{"1.5": "value"})  // ✓ Valid

// Integer constraint - rejects floats
schema := Record(Int(), String())
schema.Parse(map[string]any{"1": "ok"})       // ✓ Valid
schema.Parse(map[string]any{"1.5": "fail"})   // ✗ Error: not an integer

// Unsigned integer constraint
schema := Record(Uint(), String())
schema.Parse(map[string]any{"-1": "fail"})    // ✗ Error: negative

// Key transformation with Overwrite
schema := Record(
    Float64().Overwrite(func(n float64) float64 { return n * 2 }),
    String(),
)
// {"5": "five"} → {"10": "five"} (key doubled)

// LooseRecord passes through non-matching keys
schema := LooseRecord(Float64(), String())
result, _ := schema.Parse(map[string]any{
    "1": "one",
    "abc": "text",  // Non-numeric, passed through unchanged
})
```

**Implementation Details:**
- `isNumericKeySchema()` - Detects if key schema expects numeric type
- `convertToSchemaNumericType()` - Converts float64 to appropriate Go type (int, uint, etc.)
- `parseKeyWithSchema()` - Tries string first, falls back to numeric parsing
- Key transformations are tracked and applied to output map

**Go-Specific Behavior:**
- Scientific notation keys may be normalized: `"1e10"` → `"1e+10"`
- All output keys remain strings (Go map constraint)

---

## 16  Implementation → PR Checklist

- [ ] File respects 5-section order & headings.  
- [ ] All helper packages imported (`internal/engine`, `internal/checks`, `pkg/coerce`).  
- [ ] Both `Parse(any)` and `StrictParse(T)` implemented using engine helpers.
- [ ] `Parse` method handles `any` input with runtime type checking.
- [ ] `StrictParse` method accepts exact constraint type `T` with compile-time safety.
- [ ] Both methods share the same validation pipeline and modifier handling.
- [ ] Both `MustParse` and `MustStrictParse` implemented.
- [ ] `ParseAny` and `MustParseAny` methods implemented for untyped results.
- [ ] `GetInternals`, `IsOptional`, `IsNilable` methods implemented.
- [ ] Modifiers follow Copy-on-Write pattern + pointer conversion rules.  
- [ ] Default/Prefault accept value types, not pointers (compile-time safety).
- [ ] Enhanced modifiers implemented: `DefaultFunc`, `PrefaultFunc`, `Meta`, `Nullish`.
- [ ] Custom validation: `Refine`, `Check` and `CheckParam` methods implemented.
- [ ] Coerce method implemented for primitive types.
- [ ] Type constraints defined correctly (`T | *T` pattern).
- [ ] Comprehensive unit tests added following test guide structure.  
- [ ] Public constructors exported in `gozod.go`.  
- [ ] JSON Schema support added if applicable.
- [ ] Documentation updated for public API changes.

---

Follow this playbook and new GoZod schemas will automatically inherit the library's
performance, safety and DX guarantees.
